{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi","title":"Home"},{"location":"code-structure/","text":"Code structure \u00b6 Doctrine \u00b6 We use DoctrineExtensions on a lot of entity fields. It introduces more functionality that allows to use Doctrine more efficiently. We use: Timestampable to automatically update date fields on create and update /** * @Gedmo\\Timestampable(on=\"create\") * @ORM\\Column(type=\"datetime\", name=\"created_on\", options={\"default\": \"CURRENT_TIMESTAMP\"}) */ private DateTimeInterface $createdOn ; /** * @Gedmo\\Timestampable(on=\"update\") * @ORM\\Column(type=\"datetime\", name=\"edited_on\", options={\"default\": \"CURRENT_TIMESTAMP\"}) */ private DateTimeInterface $editedOn ; Softdeleteable to implicitly delete records. It introduces a deleted_at column on the entity, and filters doctrine methods like findAll to ignore deleted records. Sortable to make entity records sortable. E.g. the sequence column used by sortable datagrids. /** * @Gedmo\\SortablePosition * @ORM\\Column(type=\"integer\", length=11, nullable=true) */ private ? int $sequence ; /** * @Gedmo\\SortableGroup * @ORM\\Column(type=\"locale\", name=\"language\") */ private Locale $locale ;","title":"Code structure"},{"location":"code-structure/#code-structure","text":"","title":"Code structure"},{"location":"code-structure/#doctrine","text":"We use DoctrineExtensions on a lot of entity fields. It introduces more functionality that allows to use Doctrine more efficiently. We use: Timestampable to automatically update date fields on create and update /** * @Gedmo\\Timestampable(on=\"create\") * @ORM\\Column(type=\"datetime\", name=\"created_on\", options={\"default\": \"CURRENT_TIMESTAMP\"}) */ private DateTimeInterface $createdOn ; /** * @Gedmo\\Timestampable(on=\"update\") * @ORM\\Column(type=\"datetime\", name=\"edited_on\", options={\"default\": \"CURRENT_TIMESTAMP\"}) */ private DateTimeInterface $editedOn ; Softdeleteable to implicitly delete records. It introduces a deleted_at column on the entity, and filters doctrine methods like findAll to ignore deleted records. Sortable to make entity records sortable. E.g. the sequence column used by sortable datagrids. /** * @Gedmo\\SortablePosition * @ORM\\Column(type=\"integer\", length=11, nullable=true) */ private ? int $sequence ; /** * @Gedmo\\SortableGroup * @ORM\\Column(type=\"locale\", name=\"language\") */ private Locale $locale ;","title":"Doctrine"},{"location":"frontend-theming/","text":"Frontend/Theming \u00b6 Currently the module includes the CommerceDemo demo theme which is used in the preview url and to develop locally. It's built using an modern and productive stack: Tailwind CSS , a highly customisable CSS framework which can be used directly in your HTML. No more heavy CSS! Alpine.js , a lightweight tool for progressive enhancement. Sprinkle some javascript on our Twig templates. Vite , a lightning fast build tool \u26a1. Only needs a vite.config.js file, less complex than Webpack. Typescript The demo theme uses a few dependencies. We try to avoid jQuery and go for lightweight, vanilla JS libraries. E.g. Algolia Autocomplete.js which provides a simple way to create a very powerful search box. Splide , a lightweight slider and carousel written in pure Javascript without any dependencies. Notyf , a simple, minimalistic, dependency-free, ~ 3KB Javascript library for toast notifications. Photoswipe a vanilla Javascript lightbox/image gallery without dependencies. Run Vite dev server with HMR \u00b6 When we edit our .html.twig, .ts or .css files, we would like to instantly see the changes. Start the frontend dev server with: cd src/Frontend/Themes/CommerceDemo npm run dev This will start up Vite in watch-mode, and also output Typescript errors in the console. The vite_entry_link_tags and vite_entry_script_tags Twig tags in Base.html.twig will check if the dev server is running and output the appropriate tags. Read more about the Vite & Fork CMS integration at https://github.com/jessedobbelaere/fork-cms-vite-boilerplate","title":"Frontend theming"},{"location":"frontend-theming/#frontendtheming","text":"Currently the module includes the CommerceDemo demo theme which is used in the preview url and to develop locally. It's built using an modern and productive stack: Tailwind CSS , a highly customisable CSS framework which can be used directly in your HTML. No more heavy CSS! Alpine.js , a lightweight tool for progressive enhancement. Sprinkle some javascript on our Twig templates. Vite , a lightning fast build tool \u26a1. Only needs a vite.config.js file, less complex than Webpack. Typescript The demo theme uses a few dependencies. We try to avoid jQuery and go for lightweight, vanilla JS libraries. E.g. Algolia Autocomplete.js which provides a simple way to create a very powerful search box. Splide , a lightweight slider and carousel written in pure Javascript without any dependencies. Notyf , a simple, minimalistic, dependency-free, ~ 3KB Javascript library for toast notifications. Photoswipe a vanilla Javascript lightbox/image gallery without dependencies.","title":"Frontend/Theming"},{"location":"frontend-theming/#run-vite-dev-server-with-hmr","text":"When we edit our .html.twig, .ts or .css files, we would like to instantly see the changes. Start the frontend dev server with: cd src/Frontend/Themes/CommerceDemo npm run dev This will start up Vite in watch-mode, and also output Typescript errors in the console. The vite_entry_link_tags and vite_entry_script_tags Twig tags in Base.html.twig will check if the dev server is running and output the appropriate tags. Read more about the Vite & Fork CMS integration at https://github.com/jessedobbelaere/fork-cms-vite-boilerplate","title":"Run Vite dev server with HMR"},{"location":"installation/","text":"Installation \u00b6 Take a look at deploy/prepare-fork-cms.sh which executes these steps as part of the demo app. 1. Upload the module \u00b6 Install this module as usual, by copying the Commerce folder from the Backend and Frontend folders to your project. 2. Install dependencies \u00b6 This module requires extra Composer dependencies, you can install these by running: composer require tetranz/select2entity-bundle \"v2.10.1\" composer require knplabs/knp-snappy-bundle \"v1.6.0\" composer require h4cc/wkhtmltopdf-amd64 \"^0.12.4\" composer require gedmo/doctrine-extensions \"^3.0\" composer require jeroendesloovere/sitemap-bundle \"^2.0\" composer require tbbc/money-bundle ^4.1 \" # In case you want to load the demo fixtures or run unit tests composer require --dev doctrine/doctrine-fixtures-bundle composer require --dev zenstruck/foundry On macOS you can skip installing h4cc/wkhtmltopdf-amd64 and install wkhtmltopdf using: brew install --cask wkhtmltopdf Enable the bundles in your kernel: // app/AppKernel.php public function registerBundles () { $bundles = [ //... new \\Tetranz\\Select2EntityBundle\\TetranzSelect2EntityBundle (), new \\Knp\\Bundle\\SnappyBundle\\KnpSnappyBundle (), new \\Backend\\Modules\\Sitemaps\\Sitemaps (), new \\JeroenDesloovere\\SitemapBundle\\SitemapBundle (), new \\Tbbc\\MoneyBundle\\TbbcMoneyBundle (), ]; } Add the wkhtmltopdf path to your config file: # app/config/config.yml knp_snappy : pdf : enabled : true binary : % wkhtmltopdf.binary% And update your parameters.yml with the following: # After installing h4cc/wkhtmltopdf-amd64 wkhtmltopdf.binary : % kernel.root_dir%/../vendor/h4cc/wkhtmltopdf-amd64/bin/wkhtmltopdf-amd64 # Or when installing wkhtmltopdf via brew on macOS: wkhtmltopdf.binary : /usr/local/bin/wkhtmltopdf 3. Configure LiipImagineBundle filters \u00b6 Configure the following filters to your config file, to use properly resized images in the frontend. # app/config/config.yml liip_imagine : filter_sets : ... product_thumbnail : filters : auto_rotate : ~ strip : ~ scale : { dim : [ 300 , 380 ] } product_large : filters : auto_rotate : ~ strip : ~ scale : { dim : [ 600 , 800 ] } product_slider_thumbnail : filters : auto_rotate : ~ strip : ~ scale : { dim : [ 100 , 100 ] } 4. Add a Twig extension to parse script/link tags \u00b6 The frontend theme builds assets to a dist/ folder. To include these assets, Twig can use a manifest.json file. The included ViteAssetExtension.php should help do that. However, a theme cannot register Symfony services (yet), so we have to add it manually to config.yml . services : ... # Configure the twig extension for ViteJS to easily switch between dev and prod script tags Frontend\\Themes\\CommerceDemo\\ViteAssetExtension : autowire : true arguments : $environment : '%kernel.environment%' tags : - { name : twig.extension } - { name : kernel.event_listener , event : kernel.exception } Now simply build the frontend: cd src/Frontend/Themes/CommerceDemo npm run build # or npm run dev to watch for changes Start selling \u00b6 After setting up Mollie or Buckaroo you are able to sell your products! But to increase sales and SEO we added some tools. 1. Sitemap generator \u00b6 Install the sitemap generator build bij jeroondesloovere: https://github.com/friends-of-forkcms/fork-cms-module-sitemaps When you create a Cronjob you should be able to generate a sitemap each day. 2. Google Shopping Feed \u00b6 When you assign Google Shopping Categories to your categories you would be able to display products in Google Shopping. Setup is really easy: Assign the right categories Create a cronjob which generates the feed daily, the cronjob command is: php bin/console catalog:generate-merchant-feed Add the feed to your Google Mechant Center Start selling products This feeds also works for Bing!","title":"Installation"},{"location":"installation/#installation","text":"Take a look at deploy/prepare-fork-cms.sh which executes these steps as part of the demo app.","title":"Installation"},{"location":"installation/#1-upload-the-module","text":"Install this module as usual, by copying the Commerce folder from the Backend and Frontend folders to your project.","title":"1. Upload the module"},{"location":"installation/#2-install-dependencies","text":"This module requires extra Composer dependencies, you can install these by running: composer require tetranz/select2entity-bundle \"v2.10.1\" composer require knplabs/knp-snappy-bundle \"v1.6.0\" composer require h4cc/wkhtmltopdf-amd64 \"^0.12.4\" composer require gedmo/doctrine-extensions \"^3.0\" composer require jeroendesloovere/sitemap-bundle \"^2.0\" composer require tbbc/money-bundle ^4.1 \" # In case you want to load the demo fixtures or run unit tests composer require --dev doctrine/doctrine-fixtures-bundle composer require --dev zenstruck/foundry On macOS you can skip installing h4cc/wkhtmltopdf-amd64 and install wkhtmltopdf using: brew install --cask wkhtmltopdf Enable the bundles in your kernel: // app/AppKernel.php public function registerBundles () { $bundles = [ //... new \\Tetranz\\Select2EntityBundle\\TetranzSelect2EntityBundle (), new \\Knp\\Bundle\\SnappyBundle\\KnpSnappyBundle (), new \\Backend\\Modules\\Sitemaps\\Sitemaps (), new \\JeroenDesloovere\\SitemapBundle\\SitemapBundle (), new \\Tbbc\\MoneyBundle\\TbbcMoneyBundle (), ]; } Add the wkhtmltopdf path to your config file: # app/config/config.yml knp_snappy : pdf : enabled : true binary : % wkhtmltopdf.binary% And update your parameters.yml with the following: # After installing h4cc/wkhtmltopdf-amd64 wkhtmltopdf.binary : % kernel.root_dir%/../vendor/h4cc/wkhtmltopdf-amd64/bin/wkhtmltopdf-amd64 # Or when installing wkhtmltopdf via brew on macOS: wkhtmltopdf.binary : /usr/local/bin/wkhtmltopdf","title":"2. Install dependencies"},{"location":"installation/#3-configure-liipimaginebundle-filters","text":"Configure the following filters to your config file, to use properly resized images in the frontend. # app/config/config.yml liip_imagine : filter_sets : ... product_thumbnail : filters : auto_rotate : ~ strip : ~ scale : { dim : [ 300 , 380 ] } product_large : filters : auto_rotate : ~ strip : ~ scale : { dim : [ 600 , 800 ] } product_slider_thumbnail : filters : auto_rotate : ~ strip : ~ scale : { dim : [ 100 , 100 ] }","title":"3. Configure LiipImagineBundle filters"},{"location":"installation/#4-add-a-twig-extension-to-parse-scriptlink-tags","text":"The frontend theme builds assets to a dist/ folder. To include these assets, Twig can use a manifest.json file. The included ViteAssetExtension.php should help do that. However, a theme cannot register Symfony services (yet), so we have to add it manually to config.yml . services : ... # Configure the twig extension for ViteJS to easily switch between dev and prod script tags Frontend\\Themes\\CommerceDemo\\ViteAssetExtension : autowire : true arguments : $environment : '%kernel.environment%' tags : - { name : twig.extension } - { name : kernel.event_listener , event : kernel.exception } Now simply build the frontend: cd src/Frontend/Themes/CommerceDemo npm run build # or npm run dev to watch for changes","title":"4. Add a Twig extension to parse script/link tags"},{"location":"installation/#start-selling","text":"After setting up Mollie or Buckaroo you are able to sell your products! But to increase sales and SEO we added some tools.","title":"Start selling"},{"location":"installation/#1-sitemap-generator","text":"Install the sitemap generator build bij jeroondesloovere: https://github.com/friends-of-forkcms/fork-cms-module-sitemaps When you create a Cronjob you should be able to generate a sitemap each day.","title":"1. Sitemap generator"},{"location":"installation/#2-google-shopping-feed","text":"When you assign Google Shopping Categories to your categories you would be able to display products in Google Shopping. Setup is really easy: Assign the right categories Create a cronjob which generates the feed daily, the cronjob command is: php bin/console catalog:generate-merchant-feed Add the feed to your Google Mechant Center Start selling products This feeds also works for Bing!","title":"2. Google Shopping Feed"},{"location":"local-development/","text":"Local development \u00b6 Symlinking the module folders \u00b6 When developing locally, I usually create a symlinks between the folders in this git repository ( fork-cms-module-commerce ) and an actual Fork CMS installation ( fork-cms-module-commerce-demo ) to develop against in PhpStorm, e.g.: ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Backend/Modules/Commerce ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Backend/Modules/Commerce ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Backend/Modules/CommerceCashOnDelivery ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Backend/Modules/CommerceCashOnDelivery ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Backend/Modules/CommercePickup ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Backend/Modules/CommercePickup ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Frontend/Modules/Commerce ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Frontend/Modules/Commerce ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Frontend/Themes/CommerceDemo ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Frontend/Themes/CommerceDemo This is optional of course, but it's far easier than having to copy the module code from/to your Fork CMS installation each time you're ready to commit. Setup Fork CMS \u00b6 See installation on how to install and configure the module in your new Fork CMS installation. Unit testing \u00b6 Fixtures \u00b6 We use DoctrineFixturesBundle to reset and reload fixtures data in our local DB. Execute this command with the --append flag to prevent erasing the whole database: bin/console doctrine:fixtures:load --append --group = module-commerce PHPUnit \u00b6 We use PHPUnit and create fixture objects using the awesome zenstruck/foundry library. This allows for an readable and expressive, on-demand fixture system to quickly create a certain situation, e.g. ProductTest.php . Check out the Symfonycasts series on Foundry . public function it_can_get_a_discounted_price_with_vat () : void { $product = ProductFactory :: new () -> withPrice ( '299,99' ) -> withVat ( 21.00 ) -> withNewSpecial ( '240,00' , ( new DateTime ()) -> modify ( '-1 day' )) -> create (); self :: assertEquals ( '36299' , $product -> getOldPrice ( true ) -> getAmount ()); self :: assertEquals ( '29040' , $product -> getActivePrice ( true ) -> getAmount ()); self :: assertTrue ( $product -> hasActiveSpecialPrice ()); } To run the all module(s) tests, simply run simple-phpunit using the filter option to run both backend and frontend tests: bin/simple-phpunit --filter '\\\\Modules\\\\Commerce' or run them from PhpStorm: Go to 'Add Configuration' > 'New configuration' > 'PHPUnit' Enter a name and select 'Test scope: Defined in the configuration file' Enter a filter in the Test runner options: --filter '\\\\Modules\\\\Commerce' to run both frontend and backend tests. Run the tests from PhpStorm using the green play button","title":"Local development"},{"location":"local-development/#local-development","text":"","title":"Local development"},{"location":"local-development/#symlinking-the-module-folders","text":"When developing locally, I usually create a symlinks between the folders in this git repository ( fork-cms-module-commerce ) and an actual Fork CMS installation ( fork-cms-module-commerce-demo ) to develop against in PhpStorm, e.g.: ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Backend/Modules/Commerce ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Backend/Modules/Commerce ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Backend/Modules/CommerceCashOnDelivery ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Backend/Modules/CommerceCashOnDelivery ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Backend/Modules/CommercePickup ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Backend/Modules/CommercePickup ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Frontend/Modules/Commerce ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Frontend/Modules/Commerce ln -sf ~/Code/fork-cms/modules/fork-cms-module-commerce/src/Frontend/Themes/CommerceDemo ~/Code/fork-cms/modules/fork-cms-module-commerce-demo/src/Frontend/Themes/CommerceDemo This is optional of course, but it's far easier than having to copy the module code from/to your Fork CMS installation each time you're ready to commit.","title":"Symlinking the module folders"},{"location":"local-development/#setup-fork-cms","text":"See installation on how to install and configure the module in your new Fork CMS installation.","title":"Setup Fork CMS"},{"location":"local-development/#unit-testing","text":"","title":"Unit testing"},{"location":"local-development/#fixtures","text":"We use DoctrineFixturesBundle to reset and reload fixtures data in our local DB. Execute this command with the --append flag to prevent erasing the whole database: bin/console doctrine:fixtures:load --append --group = module-commerce","title":"Fixtures"},{"location":"local-development/#phpunit","text":"We use PHPUnit and create fixture objects using the awesome zenstruck/foundry library. This allows for an readable and expressive, on-demand fixture system to quickly create a certain situation, e.g. ProductTest.php . Check out the Symfonycasts series on Foundry . public function it_can_get_a_discounted_price_with_vat () : void { $product = ProductFactory :: new () -> withPrice ( '299,99' ) -> withVat ( 21.00 ) -> withNewSpecial ( '240,00' , ( new DateTime ()) -> modify ( '-1 day' )) -> create (); self :: assertEquals ( '36299' , $product -> getOldPrice ( true ) -> getAmount ()); self :: assertEquals ( '29040' , $product -> getActivePrice ( true ) -> getAmount ()); self :: assertTrue ( $product -> hasActiveSpecialPrice ()); } To run the all module(s) tests, simply run simple-phpunit using the filter option to run both backend and frontend tests: bin/simple-phpunit --filter '\\\\Modules\\\\Commerce' or run them from PhpStorm: Go to 'Add Configuration' > 'New configuration' > 'PHPUnit' Enter a name and select 'Test scope: Defined in the configuration file' Enter a filter in the Test runner options: --filter '\\\\Modules\\\\Commerce' to run both frontend and backend tests. Run the tests from PhpStorm using the green play button","title":"PHPUnit"},{"location":"money-pattern/","text":"Working with monetary values \u00b6 \"If I had a dime for every time I've seen someone use FLOAT to store currency, I'd have $999.997634\" -- Bill Karwin Floating-point calculations, often used in financial transactions, are tricky and error-prone because of how computers process them. Small mistakes can accumulate and cause severe damage to a business. For example: var_dump ( 0.0 . 1 + 0.05 === 0.06 ) // bool(false) Money can be represented using simple integers ($1.23 stored as 123), but that causes more trouble than it solves: * Integers have limited range (they can overflow silently) * Subunits can change over history * It's tricky to handle rounding, e.g. taxes: \u20ac123.45 * 1.21 equals \u20ac149.3745 but that's not a valid amount. You have to round it to \u20ac149.37. * Converting floats to int is tricky. Consider: (int) (4.10 * 100) which results in 409, not 410. The (int) cast does not handle rounding. It strips the fractional part! Using a dedicated Money library \u00b6 Money is a perfect candidate for an immutable value object. Numbers are meaningless when not combined with a currency. In Patterns of Enterprise Application Architecture , Martin Fowler describes the Money Pattern. There are endless reasons why not to represent money as a simple value (e.g. floating point calculations and rounding errors), so the Money Pattern describes a class encapsulating the amount and currency. \u201cA large proportion of the computers in this world manipulate money, so it\u2019s always puzzled me that money isn\u2019t a first-class data type in any mainstream program- ming language.\u201d \u2013 Martin Fowler It also defines all the mathematical operations on the value with respect to the currency. It stores the amount as integer in cents , the lowest possible factor of the currency. We can not divide it more. In this module we use the moneyphp/money library that implements this pattern. Some advantages are: Money objects are immutable Easy to use as Doctrine embeddable: @ORM\\Embedded(class=\"\\Money\\Money\") Easy money formatting to different locales (with IntlMoneyFormatter ) Easy conversion between currencies using converts (e.g. using Swap ) Easy to sum up money, find a minimum/maximum/average, do allocations, ... Implements JsonSerializable to convert money to JSON to exchange monetary data with other systems. As a consequence, monetary values in the MySQL database are stored in cents instead of a decimal number. A database column is added for the price_amount and price_currency_code . This is similar to how other libraries work, e.g. Stripe also expects monetary values in cents and describes it an amount as \"A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1\". Integrating moneyPHP in Symfony, Doctrine and Twig can be done using TheBigBrainsCompany/TbbcMoneyBundle . Examples \u00b6 $fiveEuro = Money :: EUR ( 500 ); // \u20ac5 $tenEuro = $fiveEuro -> add ( $fiveEuro ); // \u20ac10 $net = new Money ( 123 , new Currency ( 'USD' )); // $1.23USD $gross = $net -> multiply ( '1.10' , Money :: ROUND_UP ); // Add 10% to 1.23 = 1.353, and round it up In a Doctrine entity: // Product.php // This will create a MySQL column `price_amount` and `price_currency_code` /** * @ORM\\Embedded(class=\"\\Money\\Money\") */ private Money $price ; Or using our Twig helper function to render values: {{ cart.subTotal | format_money_decimal () }} // 5.00 {{ cart.subTotal | format_money () }} // \u20ac5.00 Warning Currently the Commerce module only supports a single currency: EURO Read more \u00b6 http://martinfowler.com/eaaCatalog/money.html https://verraes.net/2011/04/fowler-money-pattern-in-php/ https://github.com/moneyphp/money/ https://www.slideshare.net/PiotrHorzycki/how-to-count-money-using-php-and-not-lose-money","title":"Money pattern"},{"location":"money-pattern/#working-with-monetary-values","text":"\"If I had a dime for every time I've seen someone use FLOAT to store currency, I'd have $999.997634\" -- Bill Karwin Floating-point calculations, often used in financial transactions, are tricky and error-prone because of how computers process them. Small mistakes can accumulate and cause severe damage to a business. For example: var_dump ( 0.0 . 1 + 0.05 === 0.06 ) // bool(false) Money can be represented using simple integers ($1.23 stored as 123), but that causes more trouble than it solves: * Integers have limited range (they can overflow silently) * Subunits can change over history * It's tricky to handle rounding, e.g. taxes: \u20ac123.45 * 1.21 equals \u20ac149.3745 but that's not a valid amount. You have to round it to \u20ac149.37. * Converting floats to int is tricky. Consider: (int) (4.10 * 100) which results in 409, not 410. The (int) cast does not handle rounding. It strips the fractional part!","title":"Working with monetary values"},{"location":"money-pattern/#using-a-dedicated-money-library","text":"Money is a perfect candidate for an immutable value object. Numbers are meaningless when not combined with a currency. In Patterns of Enterprise Application Architecture , Martin Fowler describes the Money Pattern. There are endless reasons why not to represent money as a simple value (e.g. floating point calculations and rounding errors), so the Money Pattern describes a class encapsulating the amount and currency. \u201cA large proportion of the computers in this world manipulate money, so it\u2019s always puzzled me that money isn\u2019t a first-class data type in any mainstream program- ming language.\u201d \u2013 Martin Fowler It also defines all the mathematical operations on the value with respect to the currency. It stores the amount as integer in cents , the lowest possible factor of the currency. We can not divide it more. In this module we use the moneyphp/money library that implements this pattern. Some advantages are: Money objects are immutable Easy to use as Doctrine embeddable: @ORM\\Embedded(class=\"\\Money\\Money\") Easy money formatting to different locales (with IntlMoneyFormatter ) Easy conversion between currencies using converts (e.g. using Swap ) Easy to sum up money, find a minimum/maximum/average, do allocations, ... Implements JsonSerializable to convert money to JSON to exchange monetary data with other systems. As a consequence, monetary values in the MySQL database are stored in cents instead of a decimal number. A database column is added for the price_amount and price_currency_code . This is similar to how other libraries work, e.g. Stripe also expects monetary values in cents and describes it an amount as \"A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1\". Integrating moneyPHP in Symfony, Doctrine and Twig can be done using TheBigBrainsCompany/TbbcMoneyBundle .","title":"Using a dedicated Money library"},{"location":"money-pattern/#examples","text":"$fiveEuro = Money :: EUR ( 500 ); // \u20ac5 $tenEuro = $fiveEuro -> add ( $fiveEuro ); // \u20ac10 $net = new Money ( 123 , new Currency ( 'USD' )); // $1.23USD $gross = $net -> multiply ( '1.10' , Money :: ROUND_UP ); // Add 10% to 1.23 = 1.353, and round it up In a Doctrine entity: // Product.php // This will create a MySQL column `price_amount` and `price_currency_code` /** * @ORM\\Embedded(class=\"\\Money\\Money\") */ private Money $price ; Or using our Twig helper function to render values: {{ cart.subTotal | format_money_decimal () }} // 5.00 {{ cart.subTotal | format_money () }} // \u20ac5.00 Warning Currently the Commerce module only supports a single currency: EURO","title":"Examples"},{"location":"money-pattern/#read-more","text":"http://martinfowler.com/eaaCatalog/money.html https://verraes.net/2011/04/fowler-money-pattern-in-php/ https://github.com/moneyphp/money/ https://www.slideshare.net/PiotrHorzycki/how-to-count-money-using-php-and-not-lose-money","title":"Read more"},{"location":"preview-environments/","text":"Preview environments \u00b6 This module deploys to a preview environment using Github Actions. It uses the Okteto Kubernetes platform, which currently offers free Kubernetes deployments up to 10 pods and 5GB storage. How the preview deploy works \u00b6 The Github action preview.yml is scheduled and regularly deploys the master branch to Okteto. If a PR is created, it also creates a deploy suffixed with the PR number using the preview-pr.yml Github action. The okteto-pipeline file describes what should be deployed. It will build the container image using the Dockerfile The Dockerfile defines a stage to build our frontend theme, and a stage that starts from php:7.4-apache and installs the needed dependencies. It will also download a Fork CMS project and make sure the module copied to the right directory. It injects the container image tag, app label and deployment name in the Kubernetes files using Kustomize , and it deploys the Kubernetes files in the k8s/ folder to Okteto. The k8s/ folder defines the web deployment which deploys a single pod with two containers: the PHP app and a MariaDB container. No need for high-availability or persistant changes on a preview environment. If the pod is deleted or rescheduled, the DB resets based on the fixture data. When the container starts up, the deploy/docker-entrypoint.sh will execute a few things: Wait until the DB is up and running. Import the .sql backup of a fresh Fork CMS install in the database. Create an app/config/parameters.yml file with the right variables. We simply configure it to use the ENV vars that are defined in the container. Install a user avatar file to prevent a broken image (this is normally installed via the Fork CMS installer). Install our custom Composer dependencies required by this module Install the Sitemap Fork CMS module Install the Commerce Fork CMS module Apply a git patch that makes a few changes to the Core files: adding a bundle to AppKernel.php , adding liip_imagine presets for the thumbnails, configuring a twig extension for the Fork CMS theme, ... (\ud83d\udca1 feel free to suggest a better way to achieve this!) Generate some demo data using Doctrine Fixtures Execute some SQL queries that create a few pages in Fork CMS with the right module and widgets attached to it. Clear cache and ready to go \ud83d\ude80 The apache webserver process starts up When visiting https://fork-cms-module-commerce-demo-jessedobbelaere.cloud.okteto.net/ you should see the deployed website.","title":"Preview environments"},{"location":"preview-environments/#preview-environments","text":"This module deploys to a preview environment using Github Actions. It uses the Okteto Kubernetes platform, which currently offers free Kubernetes deployments up to 10 pods and 5GB storage.","title":"Preview environments"},{"location":"preview-environments/#how-the-preview-deploy-works","text":"The Github action preview.yml is scheduled and regularly deploys the master branch to Okteto. If a PR is created, it also creates a deploy suffixed with the PR number using the preview-pr.yml Github action. The okteto-pipeline file describes what should be deployed. It will build the container image using the Dockerfile The Dockerfile defines a stage to build our frontend theme, and a stage that starts from php:7.4-apache and installs the needed dependencies. It will also download a Fork CMS project and make sure the module copied to the right directory. It injects the container image tag, app label and deployment name in the Kubernetes files using Kustomize , and it deploys the Kubernetes files in the k8s/ folder to Okteto. The k8s/ folder defines the web deployment which deploys a single pod with two containers: the PHP app and a MariaDB container. No need for high-availability or persistant changes on a preview environment. If the pod is deleted or rescheduled, the DB resets based on the fixture data. When the container starts up, the deploy/docker-entrypoint.sh will execute a few things: Wait until the DB is up and running. Import the .sql backup of a fresh Fork CMS install in the database. Create an app/config/parameters.yml file with the right variables. We simply configure it to use the ENV vars that are defined in the container. Install a user avatar file to prevent a broken image (this is normally installed via the Fork CMS installer). Install our custom Composer dependencies required by this module Install the Sitemap Fork CMS module Install the Commerce Fork CMS module Apply a git patch that makes a few changes to the Core files: adding a bundle to AppKernel.php , adding liip_imagine presets for the thumbnails, configuring a twig extension for the Fork CMS theme, ... (\ud83d\udca1 feel free to suggest a better way to achieve this!) Generate some demo data using Doctrine Fixtures Execute some SQL queries that create a few pages in Fork CMS with the right module and widgets attached to it. Clear cache and ready to go \ud83d\ude80 The apache webserver process starts up When visiting https://fork-cms-module-commerce-demo-jessedobbelaere.cloud.okteto.net/ you should see the deployed website.","title":"How the preview deploy works"}]}